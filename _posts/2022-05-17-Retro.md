---
title: ê³¼ì œ íšŒê³ 
categories: Coursera
tags: algorithm assignment greedy
author_profile: true
published: true
---
## Coursera ê³¼ì œ íšŒê³ 

### Algorithmic Toolbox 3ì£¼ì°¨ Greedy algorithm ê³¼ì œ 5ë²ˆ ë¬¸ì œ


ë¬¸ì œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

```python
Collecting Signatures

Problem Description
Task.   Given a set of ğ‘› segments {[ğ‘0, ğ‘0], [ğ‘1, ğ‘1], . . . , [ğ‘ğ‘›âˆ’1, ğ‘ğ‘›âˆ’1]} with integer coordinates on a line, find
        the minimum number ğ‘š of points such that each segment contains at least one point. That is, find a
        set of integers ğ‘‹ of the minimum size such that for any segment [ğ‘ğ‘–, ğ‘ğ‘–] there is a point ğ‘¥ âˆˆ ğ‘‹ such
        that ğ‘ğ‘– â‰¤ ğ‘¥ â‰¤ ğ‘ğ‘–.
Input Format.   The first line of the input contains the number ğ‘› of segments. Each of the following ğ‘› lines
        contains two integers ğ‘ğ‘– and ğ‘ğ‘– (separated by a space) defining the coordinates of endpoints of the ğ‘–-th
        segment.
Constraints.    1 â‰¤ ğ‘› â‰¤ 100; 0 â‰¤ ğ‘ğ‘– â‰¤ ğ‘ğ‘– â‰¤ 10^9 for all 0 â‰¤ ğ‘– < ğ‘›.
Output Format.  Output the minimum number ğ‘š of points on the first line and the integer coordinates
        of ğ‘š points (separated by spaces) on the second line. You can output the points in any order. If there
        are many such sets of points, you can output any set. (It is not difficult to see that there always exist
        a set of points of the minimum size such that all the coordinates of the points are integers.)
```

í•´ë‹¹ ê³¼ì œ í•´ê²°ì„ ìœ„í•´ ì‘ì„±í•œ ìµœì´ˆ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

```python
def solution(segments):
    points = []
    i = 0
    
    while i < len(segments):
        point = segments[i][1]
        
        for j in range(i+1, len(segments)):
            if segments[j][0] > point:
                points.append(point)
                break
            i += 1

    return points
```
ì œì¶œ ê³¼ì •ì—ì„œ í™•ì¸í•œ í…ŒìŠ¤íŠ¸ ì…‹ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.
```python
# test-1
input: [[1,3], [2,5], [3,6]]
expected output: [3]

# test-2
input: [[4,7], [1,3], [2,5], [5,6]]
expected output: [3, 6]

# test-3
input: [[41, 42],[52,52],[63,63],[80,82],[78,79],[35,35],[22,23],[31,32],[44,45],[81, 82],[36, 38],
        [10, 12],[1, 1],[23, 23],[32, 33],[87, 88],[55, 56],[69, 71],[89, 91],[93, 93],[38, 40],[33, 34],[14, 16],
        [57, 59],[70, 72],[36, 36],[29, 29],[73, 74],[66, 68],[36, 38],[1, 3],[49, 50],[68, 70],[26, 28],[30, 30],
        [1, 2],[64, 65],[57, 58],[58, 58],[51, 53],[41, 41],[17, 18],[45, 46],[4, 4],[0, 1],[65, 67],[92, 93],[84, 85],
        [75, 77],[39, 41],[15, 15],[29, 31],[83, 84],[12, 14],[91, 93],[83, 84],[81, 81],[3, 4],[66, 67],[8, 8],[17, 19],
        [86, 87],[44, 44],[34, 34],[74, 74],[94, 95],[79, 81],[29, 29],[60, 61],[58, 59],[62, 62],[54, 56],[58, 58],
        [79, 79],[89, 91],[40, 42],[2, 4],[12, 14],[5, 5],[28, 28],[35 ,36],[7, 8],[82, 84],[49 ,51],[2, 4],[57, 59],
        [25, 27],[52, 53],[48, 49],[9, 9],[10, 10],[78, 78],[26, 26],[83, 84],[22, 24],[86, 87],[52, 54],[49, 51],
        [63, 64],[54, 54]]
expected output: [1, 4, 5, 8, 9, 10, 14, 15, 18, 23, 26, 28, 29, 30, 32, 34, 35, 36, 40, 41, 44, 46, 49, 52, 54,
 56, 58, 61, 62, 63, 65, 67, 70, 74, 77, 78, 79, 81, 84, 87, 91, 93, 95]
```
ê³¼ì œ ì œì¶œê³¼ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì‹¤íŒ¨ ê³¼ì •ì„ ë°˜ë³µí•˜ë©° ìµœì¢…ì ìœ¼ë¡œ í†µê³¼í•œ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.
```python
def optimal_points(segments):
    segments.sort(key=lambda segment: segment[1])   # ë‘ ë²ˆì§¸ ì¼€ì´ìŠ¤ì—ì„œ ì •ë ¬ë˜ì§€ ì•Šì€ ì„¸ê·¸ë¨¼íŠ¸ í•´ê²° ë¶ˆê°€ëŠ¥í•˜ì—¬ ìˆ˜ì •
    points = []
    last = False                        # ì„¸ ë²ˆì§¸ ì¼€ì´ìŠ¤ëŠ” ì „ë¶€ ë™ì¼í•œ ì´ìŠˆ
    i = 0
    
    while i < len(segments) - 1:        # ì²« ë²ˆì§¸ ì¼€ì´ìŠ¤ì—ì„œ ë¬´í•œë£¨í”„ ë°œìƒìœ¼ë¡œ ì¸í•œ ìˆ˜ì • 
        point = segments[i][1]
        
        for j in range(i+1, len(segments)):
            i += 1                      # ì²« ë²ˆì§¸ ì¼€ì´ìŠ¤ì—ì„œ ì´ë¯¸ ì¹´ìš´íŠ¸ ëœ ì„¸ê·¸ë¨¼íŠ¸ê°€ í¬í•¨ë˜ëŠ” ì´ìŠˆê°€ í™•ì¸ë˜ì„œ ìˆ˜ì •
            if point < segments[j][0]:
                if i == len(segments) - 1:  # ì„¸ ë²ˆì§¸ ì¼€ì´ìŠ¤ì—ì„œ ê³ ë¦½ëœ ë§ˆì§€ë§‰ ì„¸ê·¸ë¨¼íŠ¸ë¥¼ í¬í•¨í•˜ê¸° ìœ„í•œ ë¶„ê¸° ì¶”ê°€
                    last = True
                break
        points.append(point)            # ë‘ ë²ˆì§¸ ì¼€ì´ìŠ¤ì—ì„œ ë§ˆì§€ë§‰ ì„¸ê·¸ë¨¼íŠ¸ê°€ points ë¦¬ìŠ¤íŠ¸ì— í¬í•¨ë˜ì§€ ì•Šì•„ ìˆ˜ì •
        
    if last:                            # ì„¸ ë²ˆì§¸ ì¼€ì´ìŠ¤ëŠ” ì „ë¶€ ë™ì¼í•œ ì´ìŠˆ
        points.append(segments[i][1])
        
    return points
```
ëˆ„ë”ê¸° ë§ˆëƒ¥ ì¦‰ê°ì ì¸ ë¬¸ì œ í•´ê²°ì„ ìœ„í•´ ì½”ë“œê°€ ë•ì§€ë•ì§€ ë¶ˆì–´ë‚¬ë‹¤.   
ì‚¬ì‹¤ ë‘ ë²ˆì§¸ ì¼€ì´ìŠ¤ê¹Œì§€ëŠ” ì €ë ‡ê²Œ ì²˜ë¦¬ë˜ì–´ì•¼ í•˜ëŠ”, ê·¸ëŸ¬ë‹ˆê¹Œ í•„ìš”í•œ ìˆ˜ì •ì´ë‚˜ ì¶”ê°€ë¼ê³  ë³¼ ìˆ˜ ìˆì—ˆë‹¤.   
í•˜ì§€ë§Œ, ì„¸ ë²ˆì§¸ ì¼€ì´ìŠ¤ì—ì„œ ë°œìƒí•œ ìˆ˜ì • ì‚¬í•­ë“¤ì€ ê·¸ëŸ¬í•œ ë²”ì£¼ë¥¼ ë²—ì–´ë‚¬ë‹¤.    
ì¶”ê°€ëœ `last` ë³€ìˆ˜, `if` ë‚´ë¶€ì˜ `i == len(segments) - 1` ë¶„ê¸°, ìµœì¢…ì ìœ¼ë¡œ `last`ë¥¼ í™•ì¸í•˜ì—¬ ì›ì†Œë¥¼ ì¶”ê°€í•˜ëŠ” ì½”ë“œëŠ” ì˜ëª» ê¸°íšëœ ì•Œê³ ë¦¬ì¦˜ì„ ì–´ë–»ê²Œë“  í…ŒìŠ¤íŠ¸ë¥¼ í†µê³¼í•˜ê¸° ìœ„í•´ ê¸°ì›Œë„£ì€ ë•œë¹µì˜ í”ì ë“¤ì´ë‹¤.

ì´ëŸ° ì´ìŠˆëŠ” ë¹„ë‹¨ ê³¼ì œë‚˜ ì½”ë”©í…ŒìŠ¤íŠ¸ë¥¼ ìˆ˜í–‰í•˜ëŠ” ê³¼ì •ì—ì„œë§Œ ë°œìƒí•˜ì§„ ì•Šì„ ê²ƒì´ë‹¤. ë°ë“œë¼ì¸ì— ì«’ê¸°ëŠ” ìƒí™©, ë‹¹ì¥ ëˆˆì•ì— ì†”ë£¨ì…˜ì´ ë³´ì´ì§€ ì•ŠëŠ” ìƒí™©ì—ì„œëŠ” ì´ëŸ¬í•œ ë•œë¹µì‹ ì½”ë“œë¡œ ë‹¹ì¥ ëˆˆì•ì˜ ì¥ì• ë¬¼ì„ ë„˜ì–´ê°€ë ¤ í•  ê²ƒì´ë‹¤.   

ê·¸ë˜ì„œ ì´ë²ˆ ê³¼ì œ í’€ì´ ê³¼ì •ì„ ë‚¨ê¸´ë‹¤.   

ë¶€ë„ëŸ¬ìš´ í”ì ì„ ì–´ë”˜ê°€ì— ë¬»ì–´ë‘ì§€ ì•Šê³  ë‹¤ì‹œ ì°¾ì•„ì™€ í•´ê²°í•˜ê²Œë” í•˜ê¸° ìœ„í•´ì„œ.
